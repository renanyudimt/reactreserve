{"ast":null,"code":"import mongoose from \"mongoose\";\nimport jwt from \"jsonwebtoken\";\nimport Cart from \"../../models/Cart\";\nimport connectDb from \"../../utils/connectDb\";\nconnectDb();\nconst {\n  ObjectId\n} = mongoose.Types;\nexport default (async (req, res) => {\n  switch (req.method) {\n    case \"GET\":\n      handleGetRequest(req, res);\n      break;\n\n    case \"PUT\":\n      handlePutRequest(req, res);\n      break;\n\n    default:\n      res.status(405).send(`Method ${req.method} not allowed`);\n      break;\n  }\n});\n\nasync function handlePutRequest(req, res) {\n  if (!(\"authorization\" in req.headers)) {\n    return res.status(401).json({\n      success: false,\n      msg: \"No authorization token\"\n    });\n  }\n\n  try {\n    const {\n      quantity,\n      productId\n    } = req.body;\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET); //get user cart based on userId\n\n    const cart = await Cart.findOne({\n      user: userId\n    }); //check if product already exist\n\n    const productExist = cart.products.some(doc => ObjectId(productId).equals(doc.product)); //verifica se pelo menos 1 existe e retorna true\n    //if so, increment quantity,\n\n    if (productExist) {\n      const response = await Cart.findOneAndUpdate({\n        _id: cart._id,\n        \"products.product\": productId\n      }, {\n        $inc: {\n          \"products.$.quantity\": quantity\n        }\n      });\n      res.status(200).json({\n        success: true,\n        msg: \"Product updated successfully\",\n        response: response\n      }); //if not, add new product with quantity\n    } else {\n      const newProduct = {\n        quantity: quantity,\n        product: productId\n      };\n      const response = await Cart.findOneAndUpdate({\n        _id: cart._id,\n        \"products.product\": productId\n      }, {\n        $addToSet: {\n          products: newProduct\n        }\n      });\n      res.status(200).json({\n        success: true,\n        msg: \"Product updated successfully\",\n        response: response\n      });\n    }\n  } catch (error) {\n    console.log(\"error\", error);\n    res.status(403).json(\"Please, login again.\");\n  }\n}\n\nasync function handleGetRequest(req, res) {\n  if (!(\"authorization\" in req.headers)) {\n    return res.status(401).json({\n      success: false,\n      msg: \"No authorization token\"\n    });\n  }\n\n  try {\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET);\n    const cart = await Cart.findOne({\n      user: userId\n    }).populate({\n      path: \"products.product\",\n      model: \"Product\"\n    });\n\n    if (res.statusCode == 200) {\n      res.status(200).json({\n        success: true,\n        cart: cart.products\n      });\n    }\n  } catch (error) {\n    console.log(\"error\", error);\n    res.status(403).json({\n      success: false,\n      msg: \"Please, login again.\"\n    });\n  }\n}","map":{"version":3,"sources":["/Users/renanyudi/Sites/estudos/react-app/react-next/pages/api/cart.js"],"names":["mongoose","jwt","Cart","connectDb","ObjectId","Types","req","res","method","handleGetRequest","handlePutRequest","status","send","headers","json","success","msg","quantity","productId","body","userId","verify","authorization","process","env","JWT_SECRET","cart","findOne","user","productExist","products","some","doc","equals","product","response","findOneAndUpdate","_id","$inc","newProduct","$addToSet","error","console","log","populate","path","model","statusCode"],"mappings":"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","sourcesContent":["import mongoose from \"mongoose\";\nimport jwt from \"jsonwebtoken\";\nimport Cart from \"../../models/Cart\";\nimport connectDb from \"../../utils/connectDb\";\n\nconnectDb();\nconst { ObjectId } = mongoose.Types\n\nexport default async(req, res) => {\n\n  switch(req.method) {\n    case \"GET\":\n      handleGetRequest(req, res);\n      break;\n\n    case \"PUT\":\n      handlePutRequest(req, res);\n      break;\n    \n    default:\n      res.status(405).send(`Method ${req.method} not allowed`)\n      break\n\n  }\n}\n\nasync function handlePutRequest(req, res) {\n  if (!(\"authorization\" in req.headers)) {\n    return res.status(401).json({ success: false, msg: \"No authorization token\" })\n  }\n\n  try {\n    const { quantity, productId } = req.body;\n    const { userId } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET)\n\n    //get user cart based on userId\n    const cart = await Cart.findOne({ user: userId })\n    //check if product already exist\n    const productExist = cart.products.some(doc => ObjectId(productId).equals(doc.product)) //verifica se pelo menos 1 existe e retorna true\n    //if so, increment quantity,\n    if (productExist) {\n      const response =await Cart.findOneAndUpdate({\n        _id: cart._id,\n        \"products.product\": productId\n      }, {\n        $inc: {\n          \"products.$.quantity\": quantity\n        }\n      })\n      \n      res.status(200).json({ success: true, msg: \"Product updated successfully\", response: response })\n    //if not, add new product with quantity\n    } else {\n      const newProduct = { quantity: quantity, product: productId }\n      const response = await Cart.findOneAndUpdate({\n        _id: cart._id,\n        \"products.product\": productId\n      }, {\n        $addToSet: {\n          products: newProduct\n        }\n      })\n\n      res.status(200).json({ success: true, msg: \"Product updated successfully\", response: response })\n\n    }\n\n    \n    \n  } catch(error) {\n    console.log(\"error\", error)\n    res.status(403).json(\"Please, login again.\")\n  }\n\n}\n\nasync function handleGetRequest(req, res) {\n\n  if (!(\"authorization\" in req.headers)) {\n    return res.status(401).json({ success: false, msg: \"No authorization token\" })\n  }\n\n  try {\n    const { userId } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET)\n    const cart = await Cart.findOne({ user: userId }).populate({\n      path: \"products.product\",\n      model: \"Product\"\n    })\n\n    if (res.statusCode == 200) {\n      res.status(200).json({success: true, cart: cart.products})\n    }\n\n  } catch(error) {\n    console.log(\"error\", error)\n    res.status(403).json({ success: false, msg: \"Please, login again.\"})\n  }\n}"]},"metadata":{},"sourceType":"module"}