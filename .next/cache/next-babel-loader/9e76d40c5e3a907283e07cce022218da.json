{"ast":null,"code":"import Stripe from \"stripe\";\nimport { v4 as uuidv4 } from 'uuid';\nimport jwt from \"jsonwebtoken\";\nimport Cart from \"../../models/Cart\";\nimport Order from \"../../models/Order\";\nimport calculateCartTotal from \"../../utils/calculateCartTotal\";\nconst stripe = Stripe(process.env.STRIPE_SECRET_KEY);\nexport default async function (req, res) {\n  const {\n    paymentData\n  } = req.body;\n\n  try {\n    //1) Verify and get user from token\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET); //2) Find Cart based on user id, populate it\n\n    const cart = await Cart.findOne({\n      user: userId\n    }).populate({\n      path: \"products.product\",\n      model: \"Product\"\n    }); //3) Calculate cart totals again from cart products\n\n    const {\n      cartTotal,\n      stripeTotal\n    } = calculateCartTotal(cart.products); //4) Get de email from payment data, see if email linked with existing stripe customer \n\n    const previousCustomer = await stripe.customers.list({\n      email: paymentData.email,\n      limit: 1\n    });\n    const isExistingPreviousCustomer = previousCustomer.data.length > 0; //5) if not, create them based on their email\n\n    let newCustomer;\n\n    if (!isExistingPreviousCustomer) {\n      newCustomer = await stripe.customers.create({\n        email: paymentData.eamil,\n        source: paymentData.id\n      });\n    }\n\n    const customer = isExistingPreviousCustomer && previousCustomer.data[0].id || newCustomer.id; //6) Create charge with total, send receipt Email\n\n    await stripe.charges.create({\n      currency: \"USD\",\n      amount: stripeTotal,\n      receipt_email: paymentData.email,\n      customer,\n      description: `Checkout | ${paymentData.email} | ${paymentData.id}`\n    }, {\n      //necessario para verificar se a folha de pagamento,\n      //por qualquer que seja o motivo, nao foi executada mais de 1x, para evitar isso, se colocar uma unique string\n      idempotencyKey: uuidv4()\n    }); //7) Add order data to database \n\n    const order = await new Order({\n      userId: userId,\n      email: paymentData.email,\n      total: cartTotal,\n      products: cart.products\n    }).save(); //8) Clear products in cart\n\n    await Cart.findOneAndUpdate({\n      _id: cart._id\n    }, {\n      $set: {\n        products: []\n      }\n    }); //9) Send back success (200) response\n\n    res.status(200).json({\n      success: true,\n      msg: \"Checkout successful\"\n    });\n  } catch (error) {\n    console.log(\"error\", error);\n    res.status(500).send(\"Error processing charge\");\n  }\n}","map":{"version":3,"sources":["/Users/renanyudi/Sites/estudos/react-app/react-next/pages/api/checkout.js"],"names":["Stripe","v4","uuidv4","jwt","Cart","Order","calculateCartTotal","stripe","process","env","STRIPE_SECRET_KEY","req","res","paymentData","body","userId","verify","headers","authorization","JWT_SECRET","cart","findOne","user","populate","path","model","cartTotal","stripeTotal","products","previousCustomer","customers","list","email","limit","isExistingPreviousCustomer","data","length","newCustomer","create","eamil","source","id","customer","charges","currency","amount","receipt_email","description","idempotencyKey","order","total","save","findOneAndUpdate","_id","$set","status","json","success","msg","error","console","log","send"],"mappings":"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","sourcesContent":["import Stripe from \"stripe\"\nimport { v4 as uuidv4 } from 'uuid';\nimport jwt from \"jsonwebtoken\"\nimport Cart from \"../../models/Cart\"\nimport Order from \"../../models/Order\"\nimport calculateCartTotal from \"../../utils/calculateCartTotal\"\n\nconst stripe = Stripe(process.env.STRIPE_SECRET_KEY)\n\nexport default async function(req, res) {\n  const { paymentData } = req.body;\n  try {\n    //1) Verify and get user from token\n    const { userId } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET)\n    //2) Find Cart based on user id, populate it\n    const cart = await Cart.findOne({ user: userId }).populate({\n      path: \"products.product\",\n      model: \"Product\"\n    })\n    //3) Calculate cart totals again from cart products\n    const { cartTotal, stripeTotal } = calculateCartTotal(cart.products) \n    //4) Get de email from payment data, see if email linked with existing stripe customer \n    const previousCustomer = await stripe.customers.list({\n      email: paymentData.email,\n      limit: 1\n    })\n    const isExistingPreviousCustomer = previousCustomer.data.length > 0\n    //5) if not, create them based on their email\n    let newCustomer;\n\n    if (!isExistingPreviousCustomer) {\n      newCustomer = await stripe.customers.create({\n        email: paymentData.eamil,\n        source: paymentData.id\n      })\n    }\n\n    const customer = (isExistingPreviousCustomer && previousCustomer.data[0].id) || newCustomer.id; \n    \n    //6) Create charge with total, send receipt Email\n    await stripe.charges.create({\n      currency: \"USD\",\n      amount: stripeTotal,\n      receipt_email: paymentData.email,\n      customer,\n      description: `Checkout | ${paymentData.email} | ${paymentData.id}` \n    }, {\n      //necessario para verificar se a folha de pagamento,\n      //por qualquer que seja o motivo, nao foi executada mais de 1x, para evitar isso, se colocar uma unique string\n      idempotencyKey: uuidv4() \n    })\n    //7) Add order data to database \n    const order = await new Order({\n      userId: userId,\n      email: paymentData.email,\n      total: cartTotal,\n      products: cart.products\n    }).save()\n\n    //8) Clear products in cart\n    await Cart.findOneAndUpdate(\n      { _id: cart._id },\n      { $set: { products: [] }}\n    )\n    //9) Send back success (200) response\n    res.status(200).json({ success: true, msg: \"Checkout successful\"})\n  } catch(error) {\n    console.log(\"error\", error)\n    res.status(500).send(\"Error processing charge\")\n  }\n}"]},"metadata":{},"sourceType":"module"}