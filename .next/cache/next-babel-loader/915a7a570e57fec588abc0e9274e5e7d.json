{"ast":null,"code":"import mongoose from \"mongoose\";\nimport jwt from \"jsonwebtoken\";\nimport Cart from \"../../models/Cart\";\nimport connectDb from \"../../utils/connectDb\";\nconnectDb();\nconst {\n  ObjectId\n} = mongoose.Types;\nexport default (async (req, res) => {\n  switch (req.method) {\n    case \"GET\":\n      handleGetRequest(req, res);\n      break;\n\n    case \"PUT\":\n      handlePutRequest(req, res);\n      break;\n\n    default:\n      res.status(405).send(`Method ${req.method} not allowed`);\n      break;\n  }\n});\n\nasync function handlePutRequest(req, res) {\n  if (!(\"authorization\" in req.headers)) {\n    return res.status(401).json({\n      success: false,\n      msg: \"No authorization token\"\n    });\n  }\n\n  try {\n    const {\n      quantity,\n      productId\n    } = req.body;\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET); //get user cart based on userId\n\n    const cart = await Cart.findOne({\n      user: userId\n    }); //check if product already exist\n\n    const productExist = cart.products.some(doc => ObjectId(productId).equals(doc.product)); //verifica se pelo menos 1 existe e retorna true\n    //if so, increment quantity,\n\n    if (productExist) {\n      Cart.findOneAndUpdate({\n        _id: cart._id,\n        \"products.product\": productId\n      }, {\n        $inc: {\n          \"products.$.quantity\": quantity\n        }\n      }); //if not, add new product with quantity\n    } else {\n      const newProduct = {\n        quantity: quantity,\n        product: productId\n      };\n      await Cart.findOneAndUpdate({\n        _id: cart._id,\n        \"products.product\": productId\n      }, {\n        $addToSet: {\n          products: newProduct\n        }\n      });\n    }\n\n    res.status(200).json({\n      success: true,\n      msg: \"Product updated successfully\"\n    });\n  } catch (error) {\n    console.log(\"error\", error);\n    res.status(403).json({\n      success: false,\n      msg: \"Please, login again.\"\n    });\n  }\n}\n\nasync function handleGetRequest(req, res) {\n  if (!(\"authorization\" in req.headers)) {\n    return res.status(401).json({\n      success: false,\n      msg: \"No authorization token\"\n    });\n  }\n\n  try {\n    const {\n      userId\n    } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET);\n    const cart = await Cart.findOne({\n      user: userId\n    }).populate({\n      path: \"products.product\",\n      model: \"Product\"\n    });\n\n    if (res.statusCode == 200) {\n      res.status(200).json({\n        success: true,\n        cart: cart.products\n      });\n    }\n  } catch (error) {\n    console.log(\"error\", error);\n    res.status(403).json({\n      success: false,\n      msg: \"Please, login again.\"\n    });\n  }\n}","map":{"version":3,"sources":["/Users/renanyudi/Sites/estudos/react-app/react-next/pages/api/cart.js"],"names":["mongoose","jwt","Cart","connectDb","ObjectId","Types","req","res","method","handleGetRequest","handlePutRequest","status","send","headers","json","success","msg","quantity","productId","body","userId","verify","authorization","process","env","JWT_SECRET","cart","findOne","user","productExist","products","some","doc","equals","product","findOneAndUpdate","_id","$inc","newProduct","$addToSet","error","console","log","populate","path","model","statusCode"],"mappings":"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","sourcesContent":["import mongoose from \"mongoose\";\nimport jwt from \"jsonwebtoken\";\nimport Cart from \"../../models/Cart\";\nimport connectDb from \"../../utils/connectDb\";\n\nconnectDb();\nconst { ObjectId } = mongoose.Types\n\nexport default async(req, res) => {\n\n  switch(req.method) {\n    case \"GET\":\n      handleGetRequest(req, res);\n      break;\n\n    case \"PUT\":\n      handlePutRequest(req, res);\n      break;\n    \n    default:\n      res.status(405).send(`Method ${req.method} not allowed`)\n      break\n\n  }\n}\n\nasync function handlePutRequest(req, res) {\n  if (!(\"authorization\" in req.headers)) {\n    return res.status(401).json({ success: false, msg: \"No authorization token\" })\n  }\n\n  try {\n    const { quantity, productId } = req.body;\n    const { userId } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET)\n\n    //get user cart based on userId\n    const cart = await Cart.findOne({ user: userId })\n    //check if product already exist\n    const productExist = cart.products.some(doc => ObjectId(productId).equals(doc.product)) //verifica se pelo menos 1 existe e retorna true\n    //if so, increment quantity,\n    if (productExist) {\n      Cart.findOneAndUpdate({\n        _id: cart._id,\n        \"products.product\": productId\n      }, {\n        $inc: {\n          \"products.$.quantity\": quantity\n        }\n      })  \n    //if not, add new product with quantity\n    } else {\n      const newProduct = { quantity: quantity, product: productId }\n      await Cart.findOneAndUpdate({\n        _id: cart._id,\n        \"products.product\": productId\n      }, {\n        $addToSet: {\n          products: newProduct\n        }\n      })\n    }\n\n    res.status(200).json({ success: true, msg: \"Product updated successfully\" })\n    \n  } catch(error) {\n    console.log(\"error\", error)\n    res.status(403).json({ success: false, msg: \"Please, login again.\"})\n  }\n\n}\n\nasync function handleGetRequest(req, res) {\n\n  if (!(\"authorization\" in req.headers)) {\n    return res.status(401).json({ success: false, msg: \"No authorization token\" })\n  }\n\n  try {\n    const { userId } = jwt.verify(req.headers.authorization, process.env.JWT_SECRET)\n    const cart = await Cart.findOne({ user: userId }).populate({\n      path: \"products.product\",\n      model: \"Product\"\n    })\n\n    if (res.statusCode == 200) {\n      res.status(200).json({success: true, cart: cart.products})\n    }\n\n  } catch(error) {\n    console.log(\"error\", error)\n    res.status(403).json({ success: false, msg: \"Please, login again.\"})\n  }\n}"]},"metadata":{},"sourceType":"module"}